# MCP插件开发经验记录

## MCP规范理解与修正

在根据Python SDK文档对MCP即插即用框架进行改进的过程中，我们发现了几个重要的概念理解错误，并进行了修正：

### 1. 资源URI格式

**问题**：最初的资源插件使用了简化的URI格式如`"file"`，而不是MCP规范中建议的`"file://{file_path}"`格式。

**原因**：未充分理解MCP资源的URI模式规范，URI应包含资源的完整标识，包括协议和路径部分。

**解决方案**：
- 修改资源注册装饰器，改为`@mcp.resource("file://{path}")`格式
- 在返回资源时，添加标准化的响应结构，包括`uri`、`mimeType`和`text`属性
- 添加目录资源，使用`dir://{directory}`格式

### 2. 采样器机制

**问题**：最初错误地认为采样器插件需要自己实现LLM调用，而实际上采样是服务器向客户端请求的能力。

**原因**：对MCP协议中客户端和服务器角色在采样流程中的职责理解不清。

**解决方案**：
- 实现`request_sampling`函数，支持服务器向客户端请求LLM采样
- 增加`generate_content`工具，作为对采样能力的封装
- 保留标准`sample`处理函数，但添加警告，说明其通常不会被直接调用

### 3. 提示模板格式

**问题**：提示插件返回的格式与MCP规范不完全一致。

**原因**：未使用标准的MCP类型。

**解决方案**：
- 添加对`mcp.types`模块的兼容性检查
- 当类型可用时，使用`types.GetPromptResult`、`types.PromptMessage`等标准类型
- 保留对不支持标准类型情况的兼容处理

## 工具插件开发经验

### 1. 参数验证与类型注解

在改进工具插件时，我们增加了详细的参数验证和类型注解，这带来了几个好处：

1. **更清晰的接口定义**：使用类型注解（如`str`、`int`、`Optional[Dict]`）使函数接口更加清晰。
2. **更好的错误处理**：添加参数验证逻辑，提供明确的错误信息。
3. **向后兼容性**：为参数提供合理的默认值，确保向后兼容。

示例：
```python
@mcp.tool()
async def web_search(
    query: str, 
    num_results: int = default_num_results, 
    engine: str = default_engine, 
    lang: str = "en", 
    fetch_content: bool = False
) -> Dict[str, Any]:
    # 参数验证
    if not query or not isinstance(query, str):
        raise ValueError("搜索查询不能为空且必须是字符串")
```

### 2. 配置管理优化

我们改进了插件的配置管理，从全局配置中获取特定于插件的设置：

1. **层次化配置**：使用嵌套的配置结构，如`config.get("tool_configs", {}).get("web_search", {})`。
2. **合理默认值**：为每个配置项提供合理的默认值，确保插件在缺乏配置的情况下仍能正常工作。
3. **配置文档化**：在插件初始化日志中记录使用的配置，便于调试。

## 资源插件改进经验

### 1. MIME类型支持

为资源插件添加了MIME类型支持，使其更符合MCP规范：

1. **根据文件扩展名推断MIME类型**：如`.md`映射到`text/markdown`。
2. **目录资源使用标准MIME类型**：为目录资源使用`inode/directory`类型。
3. **二进制与文本区分**：虽然当前实现主要处理文本文件，但架构支持未来扩展到二进制文件。

### 2. 结构化目录内容

改进了目录资源的返回格式，使其更加结构化和有用：

```python
directory_content = {
    "current_directory": directory or "/",
    "files": [{"name": f, "uri": f"file://{os.path.join(directory, f)}"} for f in files],
    "directories": [{"name": d, "uri": f"dir://{os.path.join(directory, d)}"} for d in dirs]
}
```

这种格式使客户端能更容易地导航文件系统并访问资源。

## 采样器插件开发经验

### 遇到的问题

1. **采样器理解错误**
   
   最初我理解采样器插件错误，以为需要实现独立的LLM调用。然而，MCP框架本身已经提供了通过客户端调用LLM的功能，采样器插件主要是接收采样请求并协调响应处理。

   **错误原因**：对MCP协议中的采样功能理解不足，没有认识到采样行为是依赖客户端实现的。

   **解决方案**：通过查阅MCP规范，明确了采样器的作用是处理客户端发来的采样请求，而非独立实现LLM调用。采样器接收客户端实例作为参数，通过该实例调用LLM。

2. **消息格式转换复杂性**

   MCP中的消息格式和LLM的输入格式可能存在差异，需要进行转换。特别是对于多模态内容（如图像）的处理。

   **解决方案**：实现了`_format_messages`和`_format_tools`函数来处理消息和工具的格式转换，确保它们符合LLM的输入要求。

### 优化经验

1. **灵活的客户端适配**

   考虑到不同客户端可能有不同的实现方式，我们在`_generate_response`中添加了客户端检测逻辑，优先使用标准接口，并提供备选方案。

   ```python
   if hasattr(client, "sample"):
       return await client.sample(**params)
   else:
       # 备选方案
   ```

2. **错误处理与日志**

   为了方便排查问题，我们增加了详细的日志记录和错误处理机制，记录每个关键步骤的信息和可能的错误。

## 整体架构设计经验

我们成功地将OpenManus的功能迁移到基于MCP的插件式架构中，经验总结如下：

1. **模块化设计的优势**

   将功能划分为资源、工具、提示和采样四大部分，每个部分通过插件形式实现，使系统更加灵活和可扩展。

   **经验**：保持单一职责原则，每个插件只负责特定功能，避免过于复杂的依赖关系。

2. **配置管理与安全考虑**

   我们在各插件中都实现了配置读取功能，并进行了安全检查，如文件操作插件中防止路径遍历攻击。

   **经验**：始终考虑安全性，特别是对于涉及文件系统和命令执行的功能，添加必要的安全检查和限制。

3. **错误处理与恢复机制**

   在关键操作中添加了异常处理和恢复机制，提高系统健壮性。

   **经验**：优雅地处理错误是良好用户体验的关键，特别是在处理外部资源和异步操作时。

4. **清晰的插件生命周期**

   通过`setup`和`teardown`函数明确定义插件的生命周期，确保资源的正确初始化和清理。

   **经验**：良好的资源管理可以避免内存泄漏和其他运行时问题。

## 未来改进方向

1. **标准化错误代码**：实现MCP规范中定义的标准JSON-RPC错误代码。
2. **资源订阅机制**：实现资源变更通知功能。
3. **更完善的工具参数模式**：使用JSON Schema为工具参数提供更严格的验证。
4. **改进采样流程**：增强`request_sampling`功能，支持更复杂的交互模式。
5. **增加安全控制**：添加更多安全检查和权限控制机制。 